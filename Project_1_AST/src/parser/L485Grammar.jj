/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.6";
  static = true;
}

PARSER_BEGIN(L485Parser)
package parser;

import abstractSyntaxTree.*;

public class L485Parser
{

}

PARSER_END(L485Parser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~["\n","\r"])* ("\r")? "\n" >
}

TOKEN : /* Keywords */
{
  < DEFUNC : "defunc" >
| < DEFCLASS : "defclass" >
| < METHOD : "method" >
| < FUNC : "func" >
| < COND : "cond" >
| < IF : "if" >
| < THEN : "then" >
| < ELSE: "else" >
| < FI: "fi" >
| < LOAD : "load" >
| < NEW : "new" >
| < VARS: "vars" >
| < ASSIGN: "assign" >
| < TO: "to" >
| < WITH: "with" >
| < TRUE: "true" >
| < FALSE: "false" >

}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < OR : "||" >
| < AND : "&&" >
| < NOT : "!" >
| < EQUAL : "==" >
| < NOTEQUAL : "!=" >
| < LESS : "< " >
| < LESSEQUAL : "<=" >
| < GREATER: ">" >
| < GREATEREQUAL: ">=" >
| < INVOKE: "->" >
}

TOKEN :
{
  <STRING: "'"(~["'"])*"'">
| <#DIGIT: ["0" - "9"] >
| <#ALPHA: ["a" - "z"] | ["A" - "Z"] >
| <ID: <ALPHA> (<ALPHA> | <DIGIT>)*>
| <#EXPONENT: ("e" | "E") ("+" | "-")? (<DIGIT>)+ >
| <FLOATNUM: <INTNUM> (< DOT > (<DIGIT>)+ (<EXPONENT>)? | <EXPONENT>) >
| < #POSITIVE : ["1" - "9"] >
| <INTNUM: "0" | < POSITIVE > (<DIGIT>)* >
| < DOT : "." >
| < LP : "(" >
| < RP : ")" >
| < LB : "{" >
| < RB : "}" >
| < LBK: "[" >
| < RBK: "]" >
| < COMMA: "," >
}

ASTNode program():
{
	ASTNode node;
}
{
  //I removed the ()+ from this becuase it was complaining IDK why it was complaining but it was
    //You spelt because wrong
    node = functionDef()
    |
    classDef()
	|
	expression()
	|
    loadFile()
    {		return node;
    }
}

//I think this is good
ASTNode functionDef():
{
	ASTNode node, idListNode, expressionListNode;
	Token id;
}
{
    node = <DEFUNC> id = <ID> <LP> (idListNode = idList())? <RP> expressionListNode = expressionList()
    {		return new FunctionDefNode(id.image, idListNode, expressionListNode);
    }
}



//THIS THING NEEDS WORK
ASTNode idList():
{
  	ASTNode node;
	Token id;
	MaybeAListOrSomething ids;
}
{
    node = id = <ID> (<COMMA> ids.add(<ID>))*
    {
		return new idListNode(id.image, SOMETHING HERE LIKE MAYBE ids);
    }
}



//I think this is good
ASTNode classDef():
{
	ASTNode node, classVarsNode, methodsNode;
	Token id;
}
{
    node = <DEFCLASS> id = <ID> <LB> (classVarsNode = classVars())? (methodsNode = methods())? <RB>
    {
		return new ClassDefNode(id.image, classVarsNode, methodsNode);
    }
}
//I think this is good
ASTNode classVars():
{
	ASTNode node, idListNode;
}
{
    <VARS> idListNode = idList()
    {
		return new ClassVarsNode(idListNode);
    }
}


//THIS ONE PROBABLY NEEDS SOME WORK
ASTNode methods():
{
	ASTNode node, idListNode, expressionListNode;
	Token id;
}
{
    (<METHOD> id = <ID> <LP> (idListNode = idList())? <RP> expressionListNode = expressionList())+
    {
		return new MethodsNode(id.image, idListNode, expressionListNode);
    }
}





ASTNode loadFile():
{
	ASTNode node;
}
{
    <LOAD> <STRING>
    {
		return node;
    }
}
ASTNode expressionList():
{
	ASTNode node;
}
{
    <LB> (expression())+ <RB>
    {
		return node;
    }
}
ASTNode expression():
{
	ASTNode node;
}
{
    (compExpr() (logOp() compExpr())*
    |
    <NOT> compExpr())
    {
		return node;
    }
}
ASTNode logOp():
{
	ASTNode node;
}
{
    (      <OR>
    |
    <AND>
    )
    {
		return node;
    }
}
ASTNode compExpr():
{
	ASTNode node;
}
{
    addExpr() (compOp() addExpr())*
    {
		return node;
    }
}
ASTNode compOp():
{
	ASTNode node;
}
{
    (      <EQUAL>
    |
    <NOTEQUAL>
    |
    <LESS>
    |
    <LESSEQUAL>
    |
    <GREATER>
    |
    <GREATEREQUAL>
  )
    {
		return node;
    }
}
ASTNode addExpr():
{
	ASTNode node;
}
{
    mulExpr() (< PLUS > mulExpr() | < MINUS > mulExpr())*
    {
		return node;
    }
}
ASTNode mulExpr():
{
	ASTNode node;
}
{
    node = factor() (< MULTIPLY > factor() | < DIVIDE > factor())*
    {
		return node;
    }
}
ASTNode factor():
{
	ASTNode node;
}
{
    operand() (call())?
    {
		return node;
    }
}
ASTNode operand():
{
	ASTNode node;
}
{
    (      varRef()
    |
    constant()
    |
    newExpr()
    |
    ifExpr()
    |
    funcExpr()
    |
    assignExpr()
    |
    condExpr()
    |
    withExpr()
    |
    <LP> expression() <RP>
    )
    {
		return node;
    }
}
ASTNode call():
{
	ASTNode node;
}
{
    <INVOKE> <LP> (paramList())? <RP>
    {
		return node;
    }
}
ASTNode paramList():
{
	ASTNode node;
}
{
    expression() (<COMMA> expression())*
    {
		return node;
    }
}
ASTNode varRef():
{
	ASTNode node;
	Token firstID = null;
	Token secondID = null;
}
{
    firstID = <ID> (<DOT> secondID = <ID>)?
    {
		if(secondID != null)
		{			node = new varRefNode(firstID.image, secondID.image);
			return node;
		}
    }
}
ASTNode constant():
{
	ASTNode node;
}
{
    (      <INTNUM>
    |
    <FLOATNUM>
    |
    list()
    |
    <STRING>
    |
    <TRUE>
    |
    <FALSE>
  )
    {
		return node;
    }
}
ASTNode list():
{
	ASTNode node;
}
{
    <LBK> constantList() <RBK>
    {
		return node;
    }
}
ASTNode constantList():
{
	ASTNode node;
}
{
    constant() (<COMMA> constant())*
    {
		return node;
    }
}
ASTNode newExpr():
{
	ASTNode node;
}
{
    (      <NEW> <ID>
      )
    {
		return node;
    }
}
ASTNode ifExpr():
{
	ASTNode node;
}
{
    <IF> expression() <THEN> expression() <ELSE> expression() <FI>
    {
		return node;
    }
}
ASTNode funcExpr():
{
	ASTNode node;
}
{
    <FUNC> <LP> (idList())? <RP> expressionList()
    {
		return node;
    }
}
ASTNode assignExpr():
{
	ASTNode node;
}
{
    <ASSIGN> expression() <TO> <ID>
    {
		return node;
    }
}
ASTNode condExpr():
{
	ASTNode node;
}
{
    <COND> condClauses()
    {
		return node;
    }
}
ASTNode condClauses():
{
	ASTNode node;
}
{
    (<LB> expression() expression() <RB>)+
    {
		return node;
    }
}
ASTNode withExpr():
{
	ASTNode node;
}
{
    <WITH> <LP> variableDefs() <RP> expressionList()
    {
		return node;
    }
}
ASTNode variableDefs():
{
	ASTNode node;
}
{
    (<LBK> <ID> expression() <RBK>)*
    {
		return node;
    }
}
